# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
  query: RootQuery
  mutation: RootMutation
  subscription: Subscription
}

interface Challenge {
  author: User
  created: String
  difficulty: Int
  id: ID!
  isActive: Boolean
  type: String
  viewerParticipation: ChallengeParticipation
}

interface Order {
  currency: String
  id: ID!
  price: Float
  type: PaymentType
}

interface PaymentSource {
  errorMessage: PaymentErrorCodeType
  id: ID!
  redirectURL: String
  status: PaymentSourceStatus!
}

interface QuestionSemanticDuplicateInterface {
  duplicate: Question!
}

interface ValidationError {
  error: String
  path: [String!]!
  type: String!
}

union ExchangeResult = LoggedInUser | TemporaryUser

union FeedItem = Question

"""

Mandatory action may be:
- a change of terms of service that requires user explicit consent
- a new law enforcment changes like GDPR forse on companies
"""
union MandatoryAction = AcceptToSAction | UpdateProfileAction

"""

User profile status is represented by following states.
- `ProfileBlocked` - means that use must take an mandatory aciton, to unlock the profile.
- `ProfilePendingParentApproval` - means that user falls under GDPR, and guardian must take an acton in behalve of the user
"""
union ProfileStatus = ProfileActive | ProfileBlocked | ProfilePendingParentApproval

type AcceptIncomingFriendInvitationFromUserPayload {
  validationErrors: [ValidationError!]
}

type AcceptLinkingAccountsInvitationPayload {
  validationErrors: [ValidationError!]
  viewer: Viewer
}

"# User must accept terms of service"
type AcceptToSAction {
  noop: Boolean @deprecated(reason : "When backend will return `ToS Version` then this field will disappear")
}

type AddQuestionToQuestionListPayload {
  list: QuestionList
  validationErrors: [ValidationError!]
}

type Answer {
  attachments: [Attachment]
  author: User
  canComment: Boolean
  comments(before: String, last: Int): CommentConnection
  content: String!
  created: String
  databaseId: Int @deprecated(reason : "Exposed database IDs will eventually be removed in favor of global IDs")
  id: ID!
  isBest: Boolean
  isConfirmed: Boolean
  isExcellent: Boolean @deprecated(reason : "This feature is temporarly used to mark freelancers by content team")
  points: Int
  qualityScore: Int
  question: Question
  ratesCount: Int
  rating: Float
  thanksCount: Int
  verification: AnswerVerification
}

type AnswerConnection {
  hasVerified: Boolean
  nodes: [Answer]
}

type AnswerEdge {
  cursor: ID!
  node: Answer!
}

type AnswerQualityEvaluation {
  answer: Answer!
}

type AnswerVerification {
  approval: Approval
  hasAccess: Boolean
}

type AnySubjectChallenge implements Challenge {
  author: User
  created: String
  difficulty: Int
  id: ID!
  isActive: Boolean
  requirements: AnySubjectChallengeRequirements
  type: String
  viewerParticipation: ChallengeParticipation
}

type AnySubjectChallengeRequirements {
  durationInDays: Int
  numberOfAnswers: Int
  points: Int
}

type AppStoreData {
  environment: String!
  pendingRenewalInfo: [PendingRenewalInfo!]
  receipt: Receipt!
  status: Int!
}

type AppleReceipt {
  appStoreData: AppStoreData
  user: User
  valid: Boolean
}

type AppleSource implements PaymentSource {
  errorMessage: PaymentErrorCodeType
  id: ID!
  redirectURL: String
  status: PaymentSourceStatus!
}

type Approval {
  approvedTime: String
  approver: User
}

type Attachment {
  databaseId: Int @deprecated(reason : "Exposed database IDs will eventually be removed in favor of global IDs")
  extension: String @deprecated(reason : "This field should be generated by client")
  id: ID!
  thumbnailUrl: String
  url: String!
}

type BrainlyPlus {
  expirationDate: String!
  legacyRatePlan: Int! @deprecated(reason : "Used for the legacy systems before BPS")
  source: BrainlyPlusSourceType!
  status: BrainlyPlusStatus @deprecated(reason : "Used for the legacy systems before BPS")
}

type CancelOnboardingPayload {
  onboardingProgress: OnboardingProgressConnection
}

type CancelOrderPayload {
  validationErrors: [ValidationError!]
}

type CancelSubscriptionPayload {
  validationErrors: [ValidationError!]
  viewer: Viewer
}

type CancelTrialPayload {
  viewer: Viewer!
}

type CanceledOrder implements Order {
  currency: String
  id: ID!
  price: Float
  reason: OrderCancelReasonType
  type: PaymentType
}

type CardSource implements PaymentSource {
  errorMessage: PaymentErrorCodeType
  expirationDate: String!
  funding: FundingEnum!
  id: ID!
  lastFourDigits: String!
  redirectURL: String
  status: PaymentSourceStatus!
  vendor: CardVendor!
  wallet: CardWallet
}

type CardWallet {
  dynamicLastFourDigits: String
  type: CardWalletTypeEnum!
}

type Cart {
  customer: Customer!
  hash: String!
  id: ID!
  status: CartStatus!
}

type ChallengeConnection {
  edges: [ChallengeEdge!]
  nodes: [Challenge!]
  pageInfo: PageInfo!
}

type ChallengeEdge {
  cursor: ID!
  node: Challenge!
}

type ChallengeParticipation {
  endDate: String
  isCompleted: Boolean
  score: Int
  startDate: String
}

type ClaimLotteryPointsForStreakPayload {
  amount: Int!
}

type Comment {
  author: User
  content: String!
  databaseId: Int @deprecated(reason : "Exposed database IDs will eventually be removed in favor of global IDs")
  deleted: Boolean
  id: ID!
}

type CommentConnection {
  count: Int
  edges: [CommentEdge]
  pageInfo: PageInfo
}

type CommentEdge {
  cursor: ID
  node: Comment
}

type CompleteOnboardingStepPayload {
  onboardingProgress: OnboardingProgressConnection
}

type CompletedOrder implements Order {
  currency: String
  id: ID!
  nextPaymentDate: String
  price: Float
  startDate: String!
  type: PaymentType
}

type ConsentParentApprovalRequirements {
  "Whether parental approval is required for marketing"
  marketing: Boolean
  "Whether parental approval is required for profiling"
  profiling: Boolean
  "Whether parental approval is required for terms of service"
  termsOfService: Boolean
}

type CountBySubject {
  count: Int!
  markedAsBest: Int!
  subject: Subject!
}

type CreateCartPayload {
  cart: Cart
  validationErrors: [ValidationError!]
}

type CreateOrderPayload {
  order: Order
  validationErrors: [ValidationError!]
}

type CreateQuestionListPayload {
  list: QuestionList
  validationErrors: [ValidationError!]
}

type Customer {
  id: ID!
  name: String
  trial: Trial
}

type DailyAnswersBySubject {
  count: Int!
  startOfDay: String!
  subject: Subject!
}

type DailyBestAnswers {
  count: Int!
  startOfDay: String!
}

type DailyHelpedUsersCount {
  count: Int!
  startOfDay: String!
}

type DailyStreak {
  canLotteryPointsBeClaimed: Boolean!
  pointsForToday: Int!
  pointsForTomorrow: Int!
  progress: Int
  progressIncreasedToday: Boolean
}

type DailyThanks {
  count: Int!
  startOfDay: String!
}

type DeleteQuestionFromQuestionListPayload {
  list: QuestionList
  validationErrors: [ValidationError!]
}

type DeleteQuestionListPayload {
  validationErrors: [ValidationError!]
}

type Duration {
  length: Int!
  type: DurationType!
}

type EvaluateAnswerQualityPayload {
  answerQualityEvaluation: AnswerQualityEvaluation
}

type ExactQuestionDuplicate implements QuestionSemanticDuplicateInterface {
  duplicate: Question!
}

type ExchangeAppleTokenPayload {
  result: ExchangeResult
  validationErrors: [ValidationError!]
}

type ExchangeFacebookTokenPayload {
  didRegister: Boolean @deprecated(reason : "use result union to get combined abstraction on these values")
  "True when the registration is pending approval from the parent"
  pendingApproval: Boolean @deprecated(reason : "use result union to get combined abstraction on these values")
  result: ExchangeResult
  token: String @deprecated(reason : "use result union to get combined abstraction on these values")
  validationErrors: [ValidationError!]
}

type ExchangeRegistrationTokenPayload {
  authToken: String!
}

type FavoriteSubjects {
  customizationStatus: FavoriteSubjectsCustomizationStatus
  "Favorite subjects chosen by user"
  subjects: [Subject!]!
}

type Feature {
  id: Int!
  quantity: Int
}

type FeedItemConnection {
  edges: [FeedItemEdge]
  pageInfo: PageInfo
}

type FeedItemEdge {
  cursor: ID
  node: FeedItem
}

"Friends could historically be called buddies"
type FriendsInvitations {
  incoming(after: ID, databaseIds: [Int!], first: Int): IncomingFriendInvitationConnection
  outgoing(after: ID, databaseIds: [Int!], first: Int): OutgoingFriendInvitationConnection
}

type FuzzyDuplicateQuestionsConnection {
  edges: [FuzzyQuestionDuplicateEdge!]
}

type FuzzyQuestionDuplicate implements QuestionSemanticDuplicateInterface {
  duplicate: Question!
  similarity: Float!
}

type FuzzyQuestionDuplicateEdge {
  node: Question!
  similarity: Float!
}

type GenericFieldError implements ValidationError {
  error: String
  path: [String!]!
  type: String!
}

type Grade {
  databaseId: Int @deprecated(reason : "Exposed database IDs will eventually be removed in favor of global IDs")
  id: ID!
  name: String
  slug: String @deprecated(reason : "This field should be generated by the client;")
}

type InApp {
  "Time format: RFC3339"
  expires: String!
  isInIntroOfferPeriod: Boolean!
  isTrialPeriod: Boolean!
  "Time format: RFC3339"
  originalPurchaseDate: String!
  productId: String!
  "Time format: RFC3339"
  purchaseDate: String!
}

type IncomingFriendInvitation {
  "Is marked as true when user neither accept nor refuse but hide invitation"
  hidden: Boolean
  id: ID!
  inviter: User!
  "Date of sending invitation date of the user. Format: RFC 3339"
  sent: String!
}

type IncomingFriendInvitationConnection {
  count: Int!
  edges: [IncomingFriendInvitationEdge!]!
  pageInfo: PageInfo!
}

type IncomingFriendInvitationEdge {
  cursor: ID!
  node: IncomingFriendInvitation!
}

type InstantAnswerResult {
  answer: Answer
  responseID: String
}

type InviteToFriendsPayload {
  validationErrors: [ValidationError!]
}

type LatestQuestionsConnection {
  edges: [QuestionEdge]
  nodes: [Question]
}

type LoggedInUser {
  token: String!
}

"""

The result of 'logout' mutation. Currently contains only one field
that is set to true if the operation was successful. Unhandled logout errors
will yield errors instead of data.
"""
type LogoutPayload {
  loggedOut: Boolean!
}

type MarkQuestionFromQualityEvaluationAsFaultyPayload {
  question: Question
}

type ModifyLinkedAccountsStatusPayload {
  validationErrors: [ValidationError!]
  viewer: Viewer
}

type MoreRelatedAnswersConnection {
  edges: [AnswerEdge!]!
  pageInfo: PageInfo!
}

type MoreRelatedQuestionsConnection {
  edges: [QuestionEdge!]!
  pageInfo: PageInfo!
}

type NewOrder implements Order {
  currency: String
  id: ID!
  price: Float
  type: PaymentType
}

type NickAvailability {
  isAvailable: Boolean!
  recommendations: [String!]
  validationErrors: [ValidationError]
}

type Offer {
  plans: [OfferRatePlan!]!
}

type OfferRatePlan {
  plan: RatePlan!
}

type OnboardingProgressConnection {
  nodes: [OnboardingStep!]
}

type OnboardingStep {
  name: String!
  status: OnboardingStatus!
}

type OutgoingFriendInvitation {
  id: ID!
  invited: User!
  "Date of sending invitation date of the user. Format: RFC 3339"
  sent: String!
}

type OutgoingFriendInvitationConnection {
  count: Int!
  edges: [OutgoingFriendInvitationEdge!]!
  pageInfo: PageInfo!
}

type OutgoingFriendInvitationEdge {
  cursor: ID!
  node: OutgoingFriendInvitation!
}

type PBLSource implements PaymentSource {
  code: String!
  errorMessage: PaymentErrorCodeType
  id: ID!
  redirectURL: String
  status: PaymentSourceStatus!
}

type PageInfo {
  endCursor: ID
  hasNextPage: Boolean
  hasPreviousPage: Boolean
}

type ParentAcceptToSPayload {
  user: User
  validationErrors: [ValidationError!]
}

type ParentApprovalRequest {
  childDateOfBirth: String
  childEmail: String
}

type PayPalOrderPayload {
  redirectUrl: String!
}

type PaymentMethod {
  id: ID!
  name: String
  paymentProvider: PaymentProvider!
  vendors: [PaymentMethodVendor!]
}

type PaymentMethodVendor {
  code: String!
  logoUrl: String
  name: String
  status: VendorStatus!
}

type PaymentProvider {
  id: ID!
  name: String
}

type PendingRenewalInfo {
  autoRenewProductId: String!
  productId: String!
}

type PendingSource implements PaymentSource {
  errorMessage: PaymentErrorCodeType
  id: ID!
  redirectURL: String
  status: PaymentSourceStatus!
}

type Personalization {
  favoriteSubjects: FavoriteSubjects
}

type Price {
  currency: String!
  gross: Float!
  net: Float
  tax: Int
}

type ProceedOnboardingPayload {
  onboardingProgress: OnboardingProgressConnection
}

type ProfileActive {
  noop: Boolean @deprecated(reason : "When backend will return `activation date` then this field will disappear")
}

type ProfileBlocked {
  mandatoryActions: [MandatoryAction!]
}

type ProfilePendingParentApproval {
  noop: Boolean @deprecated(reason : "When backend will return `when parent action expires` then this field will disappear")
}

type Question {
  answers: AnswerConnection
  attachments: [Attachment]
  author: User
  canBeAnswered: Boolean
  canComment: Boolean
  category: QuestionCategory
  comments(before: String, last: Int): CommentConnection
  content: String
  created: String
  databaseId: Int @deprecated(reason : "Exposed database IDs will eventually be removed in favor of global IDs")
  eduLevel: Int
  fuzzyDuplicates(first: Int): FuzzyDuplicateQuestionsConnection!
  grade: Grade
  id: ID!
  isAuthorsFirstQuestion: Boolean
  isClosed: Boolean
  isPopular: Boolean @deprecated(reason : "This field is only needed for BI.")
  """

  The date of last activity on the question (including modifications
  to associated answers and comments)
  """
  lastActivity: String
  """

  Returns answers which questions are related to given question
  If User is logged in authentication token in headers should be sent.
  The guest token should be also included in cookies header
  """
  moreRelatedAnswers(after: ID, first: Int): MoreRelatedAnswersConnection!
  """

  Returns questions which are related to given question
  If User is logged in authentication token in headers should be sent.
  The guest token should be also included in cookies header
  """
  moreRelatedQuestions(after: ID, first: Int): MoreRelatedQuestionsConnection!
  next: Question
  nextToSee(after: ID, first: Int): SemanticallyRelatedQuestionsConnection!
  points: Int
  pointsForAnswer: Int
  pointsForBestAnswer: Int
  previous: Question
  "User authentication token in headers is required."
  seenByUser: SeenByViewerInformation
  similar: [SimilarQuestion]
  subject: Subject
  """

  Returns topics which are related to given question
  If User is logged in authentication token in headers should be sent.
  The guest token should be also included  in cookies header
  """
  topics(after: ID, first: Int): QuestionTopicsConnection!
}

type QuestionCategory {
  grade: Grade!
  newestQuestions(first: Int = 10): QuestionConnection
  subject: Subject!
}

type QuestionConnection {
  count: Int!
  edges: [QuestionEdge!]!
  pageInfo: PageInfo!
}

type QuestionDuplicateEdge {
  node: Question!
}

type QuestionDuplicatesConnection {
  edges: [QuestionDuplicateEdge]
}

type QuestionEdge {
  cursor: ID
  node: Question
}

type QuestionList {
  created: String!
  description: String
  grade: Grade
  id: ID!
  numberOfQuestions: Int
  questions(after: ID, first: Int!): QuestionConnection!
  title: String!
  updated: String!
}

type QuestionListConnection {
  count: Int
  edges: [QuestionListEdge!]
  pageInfo: PageInfo
}

type QuestionListEdge {
  cursor: ID!
  node: QuestionList!
}

type QuestionSearchConnection {
  count: Int
  edges: [QuestionSearchEdge!]
  pageInfo: PageInfo
}

type QuestionSearchEdge {
  cursor: ID
  highlight: SearchedQuestionHighlight
  node: Question!
}

type QuestionSemanticDuplicatesConnection {
  edges: [QuestionSemanticDuplicateInterface!]
}

type QuestionTopic {
  name: String!
  questions: QuestionConnection
  totalVerifiedQuestionsCount: Int!
}

type QuestionTopicEdge {
  cursor: ID!
  node: QuestionTopic!
}

type QuestionTopicsConnection {
  count: Int!
  edges: [QuestionTopicEdge!]!
  pageInfo: PageInfo!
}

type QuestionsToOptimizeConnection {
  edges: [QuestionEdge]
  pageInfo: PageInfo!
}

type Rank {
  databaseId: Int @deprecated(reason : "Exposed database IDs will eventually be removed in favor of global IDs")
  description: String
  id: ID!
  name: String
  next: Rank
  requirements: RankRequirements
}

type RankRequirements {
  bestAnswersInLast30Days: Int
  points: Int
}

type RatePlan {
  created: String
  description: String
  duration: Duration!
  externalId: String
  id: ID!
  name: String
  paymentMethods(paymentType: PaymentType): [PaymentMethod!]!
  price: Price!
  status: String
  trialDuration: Int!
}

type RatePlanConnection {
  edges: [RatePlanEdge!]
  pageInfo: PageInfo!
}

type RatePlanEdge {
  cursor: ID!
  node: RatePlan!
}

type RateQuestionHelpfulnessPayload {
  validationErrors: [ValidationError!]
}

type Receipt {
  inApp: [InApp!]
  "Time format: RFC3339"
  originalPurchaseDate: String!
  receiptType: AppleReceiptType!
}

type RefundSubscriptionPayload {
  subscription: Subscription
  validationErrors: [ValidationError!]
}

type RegisterPayload {
  """

  A token returned when the registration requires parental approval,
  it can be used to the registration status.
  """
  pendingToken: String
  "X-B-Token-Long used for authentication"
  token: String
  validationErrors: [ValidationError!]
}

type RegistrationParentalApproval {
  "Whether parental approval is required for marketing"
  marketing: Boolean
  "Whether parental approval is required for profiling"
  profiling: Boolean
  "Whether parental approval is required for registation"
  registration: Boolean
}

type RegistrationRules {
  "Whether the user can register"
  canRegister: Boolean
  "Parental approval rules"
  parentalApproval: RegistrationParentalApproval
}

type Relation {
  "Date of created relation. Format: RFC 3339"
  created: String!
  id: ID!
  rootUser: User!
  status: RelationStatus!
  user: User!
}

type RemindCartSharePayload {
  validationErrors: [ValidationError!]
}

type RemoveFromFriendsPayload {
  validationErrors: [ValidationError!]
}

type ReserveAnswersPendingEvaluationPayload {
  count: Int
  edges: [AnswerQualityEvaluation]
  pageInfo: PageInfo!
}

type RootMutation {
  "User authentication token in headers is required."
  acceptIncomingFriendInvitationFromUser(input: AcceptIncomingFriendInvitationFromUserInput!): AcceptIncomingFriendInvitationFromUserPayload!
  "User authentication token in headers is required."
  acceptLinkingAccountsInvitation(input: AcceptLinkingAccountsInvitationInput!): AcceptLinkingAccountsInvitationPayload!
  acceptToS(input: UserAcceptToSInput!): UserAcceptToSPayload!
  addQuestionToQuestionList(input: AddQuestionToQuestionListInput!): AddQuestionToQuestionListPayload!
  cancelOnboarding(input: CancelOnboardingInput!): CancelOnboardingPayload
  cancelOrder(id: ID!): CancelOrderPayload!
  cancelSubscription(id: ID!): CancelSubscriptionPayload!
  cancelTrial: CancelTrialPayload!
  """

  User authentication token in headers is required.
  User claims lottery points (a random number) after achieving streak.
  """
  claimLotteryPointsForStreak(input: ClaimLotteryPointsForStreakInput!): ClaimLotteryPointsForStreakPayload!
  completeOnboardingStep(input: CompleteOnboardingStepInput!): CompleteOnboardingStepPayload
  createCart(input: CreateCartInput!): CreateCartPayload!
  createCartOrder(input: CreateCartOrderInput!): CreateOrderPayload!
  createOrder(input: CreateOrderInput!): CreateOrderPayload!
  createQuestionList(input: CreateQuestionListInput!): CreateQuestionListPayload!
  deleteQuestionFromQuestionList(input: DeleteQuestionFromQuestionListInput!): DeleteQuestionFromQuestionListPayload!
  deleteQuestionList(input: DeleteQuestionListInput!): DeleteQuestionListPayload!
  "User authentication token is required"
  evaluateAnswerQuality(input: EvaluateAnswerQualityInput!): EvaluateAnswerQualityPayload
  "Log in or register user using Sign in With Apple token."
  exchangeAppleToken(input: ExchangeAppleTokenInput!): ExchangeAppleTokenPayload!
  "Log in, or register, using a Facebook token"
  exchangeFacebookToken(input: ExchangeFacebookTokenInput!): ExchangeFacebookTokenPayload
  exchangeRegistrationToken(input: ExchangeRegistrationTokenInput!): ExchangeRegistrationTokenPayload
  "User authentication token in headers is required."
  inviteToFriends(input: InviteToFriendsInput!): InviteToFriendsPayload!
  "User authentication token is required"
  logout: LogoutPayload!
  "User authentication token is required"
  markQuestionFromQualityEvaluationAsFaulty(input: MarkQuestionFromQualityEvaluationAsFaultyInput!): MarkQuestionFromQualityEvaluationAsFaultyPayload!
  """

  If User is logged in authentication token in headers should be send. The guest token should be also included
  Marking user questions as seen
  """
  markQuestionsAsSeenByUser(input: UserSeenQuestionsInput!): UserSeenQuestionsPayload!
  "User authentication token in headers is required."
  modifyLinkedAccountsStatus(input: ModifyLinkedAccountsStatusInput!): ModifyLinkedAccountsStatusPayload!
  parentAcceptToS(input: ParentAcceptToSInput!): ParentAcceptToSPayload! @deprecated(reason : "Used when parent accepted ToS")
  payPalOrder(input: PayPalOrderInput!): PayPalOrderPayload!
  proceedOnboarding(input: ProceedOnboardingInput!): ProceedOnboardingPayload
  """

  If User is logged in authentication token in headers should be send. The guest token should be also included
  User rates if page answered his question
  """
  rateQuestionHelpfulness(input: RateQuestionHelpfulnessInput!): RateQuestionHelpfulnessPayload!
  refundSubscription(input: RefundSubscriptionInput!): RefundSubscriptionPayload!
  "Register a new user with a nickname"
  register(input: RegisterInput!): RegisterPayload
  remindCartShare(input: RemindCartShareInput!): RemindCartSharePayload!
  "User authentication token in headers is required."
  removeFromFriends(input: RemoveFromFriendsInput!): RemoveFromFriendsPayload!
  "User authentication token is required"
  reserveAnswersPendingEvaluation(input: ReserveAnswersPendingEvaluationInput): ReserveAnswersPendingEvaluationPayload
  shareCartEmail(input: ShareCartEmailInput!): ShareCartEmailPayload!
  shareCartEmailForUnlock(input: ShareCartEmailForUnlockInput!): ShareCartEmailForUnlockPayload!
  "User authentication token is required"
  skipAnswerQualityEvaluation(input: SkipAnswerQualityEvaluationInput!): SkipAnswerQualityEvaluationPayload
  "Starts a user's participation in a challenge"
  startChallenge(input: StartChallengeInput!): StartChallengePayload
  submitCancelSubscriptionSurvey(input: SubmitCancelSubscriptionSurveyInput!): SubmitCancelSubscriptionSurveyPayload
  """

  If User is logged in authentication token in headers should be send. The guest token should be also included
  User gives feedback about question
  """
  submitQuestionFeedback(input: SubmitQuestionFeedbackInput!): SubmitQuestionFeedbackPayload!
  submitRegistrationOrigin(input: SubmitRegistrationOriginInput!): SubmitRegistrationOriginPayload!
  "User authentication token in headers is required."
  subscribeViewerToPushNotification(input: SubscribeViewerToPushNotificationInput!): SubscribeViewerToPushNotificationPayload!
  switchSource(input: SwitchSourceInput!): SwitchSourcePayload!
  "User authentication token in headers is required."
  thankUser(input: ThankUserInput!): ThankUserPayload!
  "Email should be base64 encoded."
  unsubscribeShareEmail(input: UnsubscribeShareEmail!): UnsubscribeShareEmailPayload!
  "User authentication token in headers is required."
  unsubscribeViewerFromPushNotification(input: UnsubscribeViewerFromPushNotificationInput!): UnsubscribeViewerFromPushNotificationPayload!
  updateAccountType(input: UpdateAccountTypeInput!): UpdateAccountTypePayload!
  updateQuestionList(input: UpdateQuestionListInput!): UpdateQuestionListPayload!
  updateUserDescription(input: UpdateUserDescriptionInput, token: String): UpdateUserDescriptionPayload
  "User authentication token in headers is required."
  updateUserFavoriteSubjects(input: UpdateUserFavoriteSubjectsInput!): UpdateUserFavoriteSubjectsPayload!
  updateUserFavoriteSubjectsCustomization(input: UpdateCustomizationStatusInput!): UpdateCustomizationStatusPayload!
  updateUserProfile(input: UpdateUserProfileInput!): UpdateUserProfilePayload!
  verifyAppleReceipt(input: VerifyAppleReceiptInput!): VerifyAppleReceiptPayload!
}

type RootQuery {
  answer(id: ID!): Answer
  answerById(id: Int!): Answer @deprecated(reason : "Exposed database IDs will eventually be removed in favor of global IDs")
  attachment(id: ID!): Attachment
  attachmentById(id: Int!): Attachment @deprecated(reason : "Exposed database IDs will eventually be removed in favor of global IDs")
  baseRanks: [Rank!]
  cartByHash(hash: String!): Cart!
  challenge(id: ID!): Challenge
  challenges(after: String, first: Int): ChallengeConnection!
  "User authentication token is required for all feed's types except PUBLIC and BRAINLIEST"
  feed(
    before: ID,
    feedType: FeedType,
    first: Int,
    "Deprecated: Exposed database IDs will eventually be removed in favor of global IDs"
    gradeIds: [Int],
    grades: [ID],
    status: FeedQuestionStatusFilter,
    "Deprecated: Exposed database IDs will eventually be removed in favor of global IDs"
    subjectIds: [Int],
    subjects: [ID]
  ): FeedItemConnection
  findSuggestedAnswer(questionContent: String!): Answer @deprecated(reason : "it does not contain responseID - use findSuggestedAnswerV2 instead")
  findSuggestedAnswerV2(questionContent: String!): InstantAnswerResult
  grade(id: ID!): Grade
  gradeById(id: Int!): Grade @deprecated(reason : "Exposed database IDs will eventually be removed in favor of global IDs")
  grades: [Grade!]
  isPayPalOrderConfirmed(id: ID!): Boolean!
  latestQuestions: FeedItemConnection
  """

  Check if given nick is available,
  if not then list of suggested nick will be returned
  """
  nickAvailability(nick: String!): NickAvailability
  offerByClientType(clientType: ClientType!): Offer!
  order(id: ID!): Order!
  """

  Details about the approval request sent to the parent for terms of
  service or marketing.
  """
  parentApprovalRequest(token: String!): ParentApprovalRequest
  paymentMethod(id: ID!): PaymentMethod
  paymentMethods: [PaymentMethod!]!
  paymentProvider(id: ID!): PaymentProvider
  paymentProviders: [PaymentProvider!]!
  paymentSource(id: ID!): PaymentSource!
  question(id: ID!): Question
  questionById(id: Int!): Question @deprecated(reason : "Exposed database IDs will eventually be removed in favor of global IDs")
  questionDuplicates(content: String!): QuestionDuplicatesConnection @deprecated(reason : "Use new node - QuestionSemanticDuplicatesConnection will return fuzzy matches too.")
  questionList(id: ID!): QuestionList
  questionSearch(after: ID, first: Int, query: String!): QuestionSearchConnection
  questionSemanticDuplicates(content: String!, fuzzy: Boolean): QuestionSemanticDuplicatesConnection
  "User authentication token is required"
  questionsToOptimize(
    before: ID,
    first: Int,
    "Deprecated: Exposed database IDs will eventually be removed in favor of global IDs"
    gradeIds: [Int],
    grades: [ID],
    "Deprecated: Exposed database IDs will eventually be removed in favor of global IDs"
    subjectIds: [Int],
    subjects: [ID]
  ): QuestionsToOptimizeConnection
  rank(id: ID!): Rank
  rankById(id: Int!): Rank @deprecated(reason : "Exposed database IDs will eventually be removed in favor of global IDs")
  ratePlan(id: ID!): RatePlan
  ratePlans: RatePlanConnection
  "Get registration rules for a particular country and age"
  registrationRules(birthday: String!, country: String!): RegistrationRules
  subject(id: ID!): Subject
  subjectById(id: Int!): Subject @deprecated(reason : "Exposed database IDs will eventually be removed in favor of global IDs")
  subjects: [Subject!]
  user(id: ID!): User
  userById(id: Int!): User @deprecated(reason : "Exposed database IDs will eventually be removed in favor of global IDs")
  viewer(token: String): Viewer
  viewerOnboardingProgress(type: OnboardingType!): OnboardingProgressConnection @deprecated(reason : "It will be removed after ProceedOnboarding node will be implemented")
}

type SearchedQuestionHighlight {
  contentFragments: [String!]
}

type SeenByViewerInformation {
  seen: Boolean!
}

type SemanticallyRelatedQuestionEdge {
  cursor: ID!
  node: Question!
  similarity: Float!
}

type SemanticallyRelatedQuestionsConnection {
  edges: [SemanticallyRelatedQuestionEdge!]
  pageInfo: PageInfo
}

type ShareCartEmailForUnlockPayload {
  validationErrors: [ValidationError!]
}

type ShareCartEmailPayload {
  validationErrors: [ValidationError!]
}

type SimilarQuestion {
  question: Question!
  similarity: Float
}

type SkipAnswerQualityEvaluationPayload {
  answerQualityEvaluation: AnswerQualityEvaluation
}

type SourceAuthorizationOrder implements Order {
  currency: String
  id: ID!
  price: Float
  redirectURL: String!
  type: PaymentType
}

type StartChallengePayload {
  viewerParticipation: ChallengeParticipation!
}

type Subject {
  bestInName: String @deprecated(reason : "This field should be generated by the client;")
  databaseId: Int @deprecated(reason : "Exposed database IDs will eventually be removed in favor of global IDs")
  icon: String
  id: ID!
  name: String
  slug: String @deprecated(reason : "This field should be generated by the client;")
}

type SubjectChallenge implements Challenge {
  author: User
  created: String
  difficulty: Int
  id: ID!
  isActive: Boolean
  requirements: SubjectChallengeRequirements
  type: String
  viewerParticipation: ChallengeParticipation
}

type SubjectChallengeRequirements {
  durationInDays: Int
  numberOfAnswers: Int
  points: Int
  subject: Subject
}

type SubjectEdge {
  cursor: ID!
  node: Subject!
}

type SubmitAnswersHelpfulnessSurveyPayload {
  validationErrors: [ValidationError!]
}

type SubmitCancelSubscriptionSurveyPayload {
  validationErrors: [ValidationError!]
}

type SubmitQuestionFeedbackPayload {
  validationErrors: [ValidationError!]
}

type SubmitRegistrationOriginPayload {
  origin: RegistrationOrigin
  validationErrors: [ValidationError!]
}

type SubscribeViewerToPushNotificationPayload {
  validationErrors: [ValidationError!]
}

type Subscription {
  canRefund: Boolean!
  expirationDate: String!
  id: ID!
  paymentType: PaymentType!
  period: SubscriptionPeriod!
  plan: SubscriptionPlan!
}

type SubscriptionConnection {
  edges: [SubscriptionEdge!]!
  pageInfo: PageInfo!
}

type SubscriptionEdge {
  cursor: ID!
  node: Subscription!
}

type SubscriptionPeriod {
  state: SubscriptionState!
  type: SubscriptionPeriodType!
}

type SubscriptionPlan {
  duration: Duration!
  price: Price!
  trialDuration: Int!
}

type SubscriptionState {
  reason: PaymentErrorCodeType
  type: SubscriptionStateType!
}

type SwitchSourcePayload {
  source: PaymentSource
  validationErrors: [ValidationError!]
}

type TemporaryUser {
  dummy: Boolean
}

type ThankUserPayload {
  validationErrors: [ValidationError!]
}

type ThanksConnection {
  count: Int!
}

type TopAnsweringSubjectsConnection {
  edges: [SubjectEdge!]!
}

type TransactionAuthorizationOrder implements Order {
  currency: String
  id: ID!
  price: Float
  redirectURL: String!
  type: PaymentType
}

type TransactionConfirmationOrder implements Order {
  currency: String
  id: ID!
  price: Float
  redirectURL: String!
  type: PaymentType
}

type Trial {
  duration: Int!
  expirationDate: String
  id: ID!
  reason: PaymentErrorCodeType
  state: TrialStateType!
  "Subscription node even though exists, will not provide actual subscription ID. Things guaranteed are duration and price."
  subscription: Subscription!
}

type UnsubscribeShareEmailPayload {
  validationErrors: [ValidationError!]
}

type UnsubscribeViewerFromPushNotificationPayload {
  validationErrors: [ValidationError!]
}

type UpdateAccountTypePayload {
  accountType: AccountType
  validationErrors: [ValidationError!]
}

type UpdateCustomizationStatusPayload {
  customizationStatus: FavoriteSubjectsCustomizationStatus
}

"# User must update his profile fields"
type UpdateProfileAction {
  fields: [String]
}

type UpdateQuestionListPayload {
  list: QuestionList
  validationErrors: [ValidationError!]
}

type UpdateUserDescriptionPayload {
  user: User
}

type UpdateUserFavoriteSubjectsPayload {
  favoriteSubjects: [Subject!]
}

type UpdateUserProfilePayload {
  validationErrors: [ValidationError!]
  viewer: Viewer
}

type User {
  "The overall number of user's answers per subjects that the user has answered to"
  answerCountBySubject(ids: [ID!]): [CountBySubject!]
  answererLevel: AnswererLevel
  "timezone field standard: tz database e.g. \"Europe/Berlin\". IANA source: https://www.iana.org/time-zones"
  answeringStreak(timezone: String): DailyStreak
  "Answers created by user"
  answers(before: ID, first: Int): UserAnswersConnection
  avatar: Attachment
  "The amount of answers created by the user, marked as \"Best\""
  bestAnswersCount: Int
  "Fixed number of days, used i.e. as a base requirement for rank level up."
  bestAnswersCountInLast30Days: Int
  category: Int @deprecated(reason : "This field will be removed in the future")
  clientType: ClientType @deprecated(reason : "This field will be removed in the future")
  "Registration date of the user. Format: RFC 3339"
  created: String!
  databaseId: Int @deprecated(reason : "Exposed database IDs will eventually be removed in favor of global IDs")
  description: String
  "Historically it could be called \"buddies\""
  friends(after: ID, databaseIds: [Int!], first: Int): UserConnection
  gender: Gender
  grade: Grade!
  "timezone field standard: tz database e.g. \"Europe/Berlin\". IANA source: https://www.iana.org/time-zones"
  helpedUsersCount(timezone: String): Int
  id: ID!
  isDeleted: Boolean @deprecated(reason : "This field will be removed, instead null will be returned for the user")
  nick: String
  points: Int
  "timezone field standard: tz database e.g. \"Europe/Berlin\". IANA source: https://www.iana.org/time-zones"
  progress(timezone: String): UserProgress
  "Questions asked by user"
  questions(before: ID, first: Int): UserQuestionsConnection
  rank: Rank
  receivedThanks: Int
  specialRanks: [Rank!]
  "thanks that the user received directly for its account, not to be confused with thanks for answers etc."
  thanks(after: ID, first: Int): ThanksConnection
  "The amount of thanks received for user's answers"
  thanksForAnswerCount: Int
  topAnsweringSubjects: TopAnsweringSubjectsConnection
}

type UserAcceptToSPayload {
  validationErrors: [ValidationError!]
  viewer: Viewer
}

type UserAnswersConnection {
  count: Int!
  edges: [AnswerEdge!]!
  pageInfo: PageInfo!
}

type UserConnection {
  count: Int!
  edges: [UserEdge!]!
  pageInfo: PageInfo!
}

type UserEdge {
  node: User!
}

type UserProgress {
  dailyAnswersBySubjectInLast14Days: [DailyAnswersBySubject!]
  dailyBestAnswersInLast14Days: [DailyBestAnswers!]
  dailyHelpedUsersCountInLast14Days: [DailyHelpedUsersCount!]
  dailyThanksInLast14Days: [DailyThanks!]
}

type UserQuestionsConnection {
  count: Int!
  edges: [QuestionEdge!]!
  pageInfo: PageInfo!
}

type UserRelation {
  invitationHash: String!
  relations: [Relation!]!
}

type UserSeenQuestionsPayload {
  validationErrors: [ValidationError!]
}

type VerifyAppleReceiptPayload {
  receipt: AppleReceipt
}

type Viewer {
  accountType: AccountType
  activeOrders: [Order!]
  brainlyPlus: BrainlyPlus
  cart: Cart
  challenges: ChallengeConnection!
  consentParentApprovalRequired: ConsentParentApprovalRequirements
  country: String
  currentSubscription: Subscription
  dateOfBirth: String
  favoriteSubjects: FavoriteSubjects @deprecated(reason : "Use Viewer.Personalization.favoriteSubjects instead")
  friendsInvitations: FriendsInvitations
  lastAnswerTime: String
  paymentSource: PaymentSource
  personalization: Personalization
  privileges: ViewerPrivileges
  questionLists(after: ID, first: Int!): QuestionListConnection
  status: ProfileStatus
  subscription(id: ID!): Subscription
  subscriptions(states: [SubscriptionStateType!]): SubscriptionConnection!
  trial: Trial
  user: User
  userRelation: UserRelation
  warnings: WarningConnection
}

type ViewerPrivileges {
  canAccessPopularFeed: Boolean
}

type WalletSource implements PaymentSource {
  errorMessage: PaymentErrorCodeType
  id: ID!
  name: String
  redirectURL: String
  status: PaymentSourceStatus!
  vendor: WalletSourceVendor!
}

type WarningConnection {
  count: Int!
}

enum AccountType {
  PARENT
  STUDENT
  TEACHER
}

enum AnswererLevel {
  INTERMEDIATE
  LURKER
  NEWBIE
  STRONG
}

enum AppleReceiptType {
  Production
  ProductionSandbox
  ProductionVPP
  ProductionVPPSandbox
}

enum BrainlyPlusSourceType {
  BPS
  INHERITED
  MANUAL
  MOBILTEK
  PAYPAL
  PAYPAL_TRIAL
  TRIAL
  ZUORA
}

enum BrainlyPlusStatus {
  ACTIVE
  CANCELED
}

enum CardVendor {
  AMERICAN_EXPRESS
  DINERS_CLUB
  DISCOVER
  JCB
  MAESTRO
  MASTERCARD
  MIR
  UNIONPAY
  UNKNOWN
  VISA
}

enum CardWalletTypeEnum {
  APPLE_PAY
  GOOGLE_PAY
}

enum CartStatus {
  CLOSED
  CONVERTED
  NEW
}

enum ClientType {
  ANDROID
  DESKTOP_WEB
  IOS
  MOBILE_WEB
}

enum DurationType {
  DAY
  MINUTE
  MONTH
}

enum FavoriteSubjectsCustomizationStatus {
  CANCELLED
  COMPLETED
  NOT_STARTED
}

enum FeedQuestionStatusFilter {
  ALL
  ANSWERED
  ANSWERING_STARTED
  ANSWER_NEEDED
  CANNOT_ANSWER @deprecated(reason : "This value will be removed in the future")
  CAN_ANSWER
}

enum FeedType {
  BRAINLIEST
  POPULAR
  PUBLIC
}

enum FundingEnum {
  CREDIT
  DEBIT
  PREPAID
  UNKNOWN
}

enum Gender {
  FEMALE
  MALE
}

enum OnboardingStatus {
  CANCELLED
  COMPLETED
  PENDING
  STARTED
}

"# Onboarding operations ##"
enum OnboardingType {
  WELCOME
}

enum OrderCancelReasonType {
  AUTHENTICATION_FAILED
  CARD_EXPIRED
  CARD_INCORRECT_CARDHOLDER_DATA
  CARD_INVALID_CVV
  CARD_INVALID_NUMBER
  CARD_NOT_ACTIVATED
  CARD_RESTRICTED
  CARD_RESTRICTED_CHARGEBACK
  CARD_TYPE_NOT_ACCEPTED
  CUSTOMER_WALLET_ERROR
  DECLINED_BY_ACQUIRING_BANK
  DECLINED_BY_ISSUING_BANK
  DUPLICATE_TRANSACTION
  EXCEEDS_DAILY_LIMIT
  EXTERNAL
  FINGERPRINT_CHECK
  FINGERPRINT_DECLINED_ON_CHECK
  FRAUD_DECLINED_ON_CHECK
  FRAUD_IP_ADDRESS
  FRAUD_STOLEN_CARD
  INSUFFICIENT_FUNDS
  INTERNAL
  TEMPORARY_HOLD
  THREE_DS_REQUIRED
  TRANSACTION_NOT_PERMITTED
  VOID_NOT_SUPPORTED
}

enum PaymentErrorCodeType {
  AUTHENTICATION_FAILED
  CARD_EXPIRED
  CARD_INCORRECT_CARDHOLDER_DATA
  CARD_INVALID_CVV
  CARD_INVALID_NUMBER
  CARD_NOT_ACTIVATED
  CARD_RESTRICTED
  CARD_RESTRICTED_CHARGEBACK
  CARD_TYPE_NOT_ACCEPTED
  CUSTOMER_WALLET_ERROR
  DECLINED_BY_ACQUIRING_BANK
  DECLINED_BY_ISSUING_BANK
  DUPLICATE_TRANSACTION
  EXCEEDS_DAILY_LIMIT
  EXTERNAL
  FINGERPRINT_CHECK
  FINGERPRINT_DECLINED_ON_CHECK
  FRAUD_DECLINED_ON_CHECK
  FRAUD_IP_ADDRESS
  FRAUD_STOLEN_CARD
  INSUFFICIENT_FUNDS
  INTERNAL
  TEMPORARY_HOLD
  THREE_DS_REQUIRED
  TRANSACTION_NOT_PERMITTED
}

enum PaymentSourceStatus {
  PENDING
  REGISTERED
  REGISTRATION_FAILED
}

enum PaymentType {
  NOT_RECURRING
  RECURRING
}

enum PushNotificationType {
  ANSWERING_ENDED
  ANSWERING_STARTED
  APPROVED_ANSWER_ANSWERER
  APPROVED_ANSWER_ASKER
  BEST_ANSWER_CHOSEN
  CHOOSE_BEST_ANSWER
  DEFAULT
  EDIT_ANSWER
  NEW_COMMENT
  NEW_FOLLOWER
  NEW_MESSAGE
  NEW_QUESTION_FROM_FOLLOWEE
  NEW_QUESTION_RESPONSE
  NEW_RANK
  REFERALL_FRIEND_INSTALLED
  THANKS_FOR_RESPONSE
  WARNING_GIVEN
}

enum QuestionFaultReasonType {
  INCOMPLETE
  OTHER
}

enum QuestionStatus {
  ANSWERING_STARTED
  ANSWER_NEEDED
  CANNOT_ANSWER
  CAN_ANSWER
}

enum RegistrationOrigin {
  FAMILY
  FRIENDS
  OTHER
  SEARCH
  SOCIAL_MEDIA
  TV
}

enum RelationStatus {
  LINKED
  UNLINKED
}

enum ReserveAnswersPendingEvaluationFeedType {
  QUALITY_ASSURANCE
  QUALITY_IMPROVEMENT
}

enum SubmitCancelSubscriptionSurveyReason {
  ANOTHER_SITE
  CAN_NOT_AFFORD
  CLASS_ENDED
  DISAPPOINTING_FEATURES
  DISAPPOINTING_QUALITY
  NOT_PLANNED_KEEPING
  OTHER
  TECHNICAL_ISSUES
  THANK_YOU
}

enum SubscriptionPeriodType {
  PAID
  TRIAL
}

enum SubscriptionStateType {
  CANCELED
  EXTENDED
  GRACE_PERIOD
  NEW
  REJECTED
  STARTED
  SUSPENDED
  SUSTAINED
  TERMINATED
}

enum TrialStateType {
  CANCELED
  CONVERTED
  GRACE_PERIOD
  NEW
  REJECTED
  STARTED
  TERMINATED
}

enum VendorStatus {
  AVAILABLE
  DISABLED
  TEMPORARILY_UNAVAILABLE
}

enum WalletSourceVendor {
  PAY_PAL
}

input AcceptIncomingFriendInvitationFromUserInput {
  inviterUserDatabaseId: Int!
}

input AcceptLinkingAccountsInvitationInput {
  invitationHash: String!
  status: RelationStatus!
}

input AddQuestionToQuestionListInput {
  listId: ID!
  questionId: ID!
}

input CancelOnboardingInput {
  type: OnboardingType!
}

input ClaimLotteryPointsForStreakInput {
  "The field exist only for the input not to be empty and allow extensions in the future."
  dummy: Boolean
}

input CompleteOnboardingStepInput {
  step: String!
  type: OnboardingType!
}

input CreateCartInput {
  name: String
}

input CreateCartOrderInput {
  """

  Additional provider data for integrations:
  - PayU/ru/CC: "token", "firstName", "lastName", "phone"
     - Stripe/ru/CC: "token"
  """
  additionalData: [KeyValueInput!]!
  cartId: ID!
  paymentMethodId: ID!
  paymentType: PaymentType!
  ratePlanId: ID!
  requestId: String!
  sourceUrl: String
  withTrial: Boolean
}

input CreateOrderInput {
  """

  Additional provider data for integrations:
  - PayU/ru/CC: "token", "firstName", "lastName", "phone"
     - Stripe/ru/CC: "token"
  """
  additionalData: [KeyValueInput!]!
  paymentMethodId: ID!
  paymentType: PaymentType!
  ratePlanId: ID!
  requestId: String!
  sourceUrl: String
  withTrial: Boolean
}

input CreateQuestionListInput {
  description: String
  gradeId: ID!
  title: String!
}

input DeleteQuestionFromQuestionListInput {
  listId: ID!
  questionId: ID!
}

input DeleteQuestionListInput {
  id: ID!
}

input EvaluateAnswerQualityInput {
  answerId: ID!
  score: Int!
}

input ExchangeAppleTokenInput {
  acceptedTermsOfService: Boolean
  country: String
  dateOfBirth: String
  email: String
  entry: String
  nick: String
  parentEmail: String
  "The Identity Token (JWT) containing the Apple user identifier and email"
  providerToken: String!
  referrer: String
}

input ExchangeFacebookTokenInput {
  acceptedTermsOfService: Boolean
  country: String
  dateOfBirth: String
  email: String
  entry: String
  nick: String
  parentEmail: String
  providerToken: String!
  referrer: String
}

input ExchangeRegistrationTokenInput {
  token: String!
}

input InviteToFriendsInput {
  invitedUserDatabaseId: Int!
}

input KeyValueInput {
  key: String!
  value: String!
}

input MarkQuestionFromQualityEvaluationAsFaultyInput {
  questionId: ID!
  reason: QuestionFaultReasonType!
}

input ModifyLinkedAccountsStatusInput {
  relationId: ID!
  status: RelationStatus!
}

"Parent accepts Terms Of Service (tos) in behalve of the kid."
input ParentAcceptToSInput {
  parentToken: String!
}

input PayPalOrderInput {
  cancelUrl: String!
  subscriptionPlanId: String!
  successUrl: String!
}

input ProceedOnboardingInput {
  type: OnboardingType!
}

input RateQuestionHelpfulnessInput {
  questionDatabaseId: Int!
  "rating range is 1-5"
  rating: Int!
}

input RefundSubscriptionInput {
  id: ID!
}

input RegisterInput {
  acceptedTermsOfService: Boolean
  accountType: AccountType
  country: String!
  dateOfBirth: String!
  email: String
  entry: String
  nick: String!
  parentEmail: String
  password: String
  referrer: String
}

input RemindCartShareInput {
  "The field exist only for the input not to be empty and allow extensions in the future."
  dummy: Boolean
}

input RemoveFromFriendsInput {
  friendUserDatabaseId: Int!
}

input ReserveAnswersPendingEvaluationInput {
  before: ID
  feed: ReserveAnswersPendingEvaluationFeedType
  first: Int
  "Deprecated: Exposed database IDs will eventually be removed in favor of global IDs"
  gradeIds: [Int]
  grades: [ID]
  "Deprecated: Exposed database IDs will eventually be removed in favor of global IDs"
  subjectIds: [Int]
  subjects: [ID]
}

input ShareCartEmailForUnlockInput {
  cartHash: String!
  customerName: String
  email: String!
  source: String
}

input ShareCartEmailInput {
  cartHash: String!
  customerName: String
  email: String!
  source: String
}

input SkipAnswerQualityEvaluationInput {
  answerId: ID!
}

input StartChallengeInput {
  challengeId: ID!
}

input SubmitAnswersHelpfulnessSurveyInput {
  questionDatabaseId: Int!
  rating: Int!
}

input SubmitCancelSubscriptionSurveyInput {
  responses: [SubmitCancelSubscriptionSurveyResponseInput!]!
  source: BrainlyPlusSourceType!
}

input SubmitCancelSubscriptionSurveyResponseInput {
  details: String
  reason: SubmitCancelSubscriptionSurveyReason!
}

input SubmitQuestionFeedbackInput {
  questionDatabaseId: Int!
  "max length is 500"
  reason: String!
}

input SubmitRegistrationOriginInput {
  origin: RegistrationOrigin!
}

input SubscribeViewerToPushNotificationInput {
  clientToken: String!
  clientType: ClientType!
  notificationChannels: [PushNotificationType!]!
}

input SwitchSourceInput {
  "Additional data that is not schema bound, i.e. sending experiments or encryptedCvv for some merchants."
  additionalData: [KeyValueInput!]
  paymentMethodId: ID!
  paymentProviderId: ID!
  returnUrl: String
  token: String
}

input ThankUserInput {
  thankedUserDatabaseId: Int!
}

input UnsubscribeShareEmail {
  email: String!
}

input UnsubscribeViewerFromPushNotificationInput {
  clientToken: String!
}

input UpdateAccountTypeInput {
  type: AccountType!
}

input UpdateCustomizationStatusInput {
  status: FavoriteSubjectsCustomizationStatus!
}

input UpdateQuestionListInput {
  description: String
  gradeId: ID
  id: ID!
  title: String
}

input UpdateUserDescriptionInput {
  description: String
}

input UpdateUserFavoriteSubjectsInput {
  favoriteSubjectsIds: [Int!]!
}

"""

Update user profile.
User now must declare country and his date of birht.
"""
input UpdateUserProfileInput {
  country: String!
  dateOfBirth: String!
}

"""

User accepts terms and services. If the user is below the age
of being able to give consent, a parent email will need to be provided
for the parent to approve the terms of service for the user.
"""
input UserAcceptToSInput {
  parentEmail: String
}

input UserSeenQuestionInput {
  questionDatabaseId: Int!
  "Date of seen question. Format: RFC 3339"
  seenAt: String!
}

input UserSeenQuestionsInput {
  questions: [UserSeenQuestionInput!]!
}

input VerifyAppleReceiptInput {
  receipt: String!
}
